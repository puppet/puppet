# Supporting logic for the parser.
# Note that the name of the contained class and the file name needs to be different
# as the class is generated by Racc, and this file is included as a mix in
#
class Puppet::Pops::Impl::Parser::Parser

  require 'puppet/pops/api/model/model'
  require 'puppet/pops/impl/model/factory'
  require 'puppet/parser/functions'
  require 'puppet/parser/files'
  require 'puppet/resource/type_collection'
  require 'puppet/resource/type_collection_helper'
  require 'puppet/resource/type'
  require 'monitor'
  
  # Simplify access to the Model factory
  Factory = Puppet::Pops::Impl::Model::Factory
  
  # Simplify access to Model (not terribly thrilled about making parser depend on model,
  # but would otherwise require depending on something else that knows about semnatics
  #
  Model = Puppet::Pops::API::Model
  Factory = Puppet::Pops::Impl::Model::Factory

  include Puppet::Resource::TypeCollectionHelper

  attr_reader :version
  attr_reader :environment
  attr_accessor :files

  attr_accessor :lexer
  
  attr_accessor :result # ?? WAT

  # Uninvestigated... TODO Get rid of this?
  #
  def ast_context(include_docs = false, ast_line = nil)
    result = {
      :line => ast_line || lexer.line,
      :file => lexer.file
    }
    result[:doc] = lexer.getcomment(result[:line]) if include_docs
    result
  end

  # Returns the token text of the given lexer token, or nil, if token is nil
  def token_text t
    return t if t.nil?
    t = t.current if t.respond_to?(:current)
    return t.value if t.is_a? Model::QualifiedName

    # else it is a lexer token
    t[:value]
  end
  
  # The fully qualified name, with the full namespace.
  # @deprecated The given name should be used, and the resulting (absolute) name computed when evaluating.
  # @todo Remove this and update the grammar to not make these calls when evaluation of nested classes
  #  have been fully implemented and tested.
  # @todo This may also make it possible to relieve the lexer from keeping track of namespace
  #
  # Aaaaargh!!! This is needed because class bodies are lazily evaluated and an inner class may not
  # have been evaluated before some external reference is made to it; it must know its complete name.
  # What a joke!
  #
  def classname(name)
      [@lexer.namespace, name].join("::").sub(/^::/, '')
#    name
#    # [@lexer.namespace, name].join("::").sub(/^::/, '')
  end

  # Reinitializes variables (i.e. creates a new lexer instance
  #
  def clear
    initvars
  end

  # Raises a Parse error.
  def error(message, options = {})
    if brace = @lexer.expected
      message += "; expected '%s'"
    end
    except = Puppet::ParseError.new(message)
    except.line = options[:line] || @lexer.line
    except.file = options[:file] || @lexer.file

    raise except
  end

  # Parses a file expected to contain pp DSL logic.
  def parse_file(file)
    unless FileTest.exist?(file)
      unless file =~ /\.pp$/
        file = file + ".pp"
      end
    end
    @lexer.file = file
    _parse()
  end

#  # import is no longer supported
#  #
#  def import(file)
#    known_resource_types.loader.import(file, @lexer.file)
#  end

  # TODO: gets or creates an environment (WRONG RESPONSABILITY) - parser gets to executor which
  # represents the environment, which holds on to loaders and such.
  # Since the parser is not responsible for importing (removed), and does not perform linking,
  # and there is no syntax that requires knowing if something referenced exists, it is safe
  # to assume that no environment is needed when parsing. (All that comes later).
  #
  def initialize()
#    # The environment is needed to know how to find the resource type collection.
#    @environment = env.is_a?(String) ? Puppet::Node::Environment.new(env) : env
    initvars
  end

  # Initializes the parser support by creating a new instance of {Puppet::Pops::Parser::Lexer}
  # @return [void]
  #
  def initvars
    @lexer = Puppet::Pops::Impl::Parser::Lexer.new
  end


  # This is probably a callback from the generated grammar (when an error occurs while parsing)
  # TODO Picks up origin information from the lexer, probably needs this from the caller instead
  #   (for code strings, and when start line is not line 1 in a code string (or file), etc.)
  #
  def on_error(token,value,stack)
    if token == 0 # denotes end of file
      value = 'end of file'
    else
      value = "'#{value[:value]}'"
    end
    error = "Syntax error at #{value}"

    if brace = @lexer.expected
      error += "; expected '#{brace}'"
    end

    except = Puppet::ParseError.new(error)
    except.line = @lexer.line
    except.file = @lexer.file if @lexer.file

    raise except
  end

  # Parses a String of pp DSL code.
  # @todo make it possible to pass a given origin
  #
  def parse_string(code)
    @lexer.string = code
    _parse()
  end
  
  # Mark the factory wrapped model object with location information
  # @todo the lexer produces :line for token, but no offset or length
  # @return [Puppet::Pops::Impl::Model::Factory] the given factory
  # @api private
  #
  def loc factory, start_token, end_token = nil
    begin
    factory.line(start_loc(start_token), end_loc(end_token))
    rescue TypeError
      puts("start token: ", start_loc(start_token))
      puts("end token: ", end_loc(end_token))
    end
  end
  
  def start_loc(o)
    if !o
      nil
    elsif o.is_a? Puppet::Pops::Impl::Model::Factory
      # It is a built model element with loc set returns start at pos 0
      o.loc()[0]
    else
      # It must be a token
      o[:line]
    end
  end
  def end_loc(o)
    if !o
      nil
    elsif o.is_a? Puppet::Pops::Impl::Model::Factory
      # It is a built model element with loc set returns start at pos 0
      o.loc()[1]
    else
      # It must be a token
      o[:line]
    end
  end
  
  def aryfy(o)
    o = [o] unless o.is_a?(Array)
    o
  end

  # Transforms an array of expressions containing literal name expressions to calls if followed by an
  # expression, or expression list
  #
  def transform_calls(expressions)
    expressions.reduce([]) do |memo, expr|
      expr = expr.current if expr.respond_to?(:current)
      name = memo[-1]
      if name.is_a? Model::QualifiedName
        memo[-1] = Factory.CALL_NAMED(name, false, aryfy(expr))
      else
        memo << expr
      end
      if expr.is_a?(Model::CallNamedFunctionExpression)
        # patch expression function call to statement style
        # TODO: This is kind of meaningless, but to make it compatible...
        expr.rval_required = false
      end
      memo
    end
    
  end
  # Performs the parsing and returns the resulting model.
  # The lexer holds state, and this is setup with {#parse_string}, or {#parse_file}.
  #
  # TODO: Drop support for parsing a ruby file this way (should be done where it is decided
  #   which file to load/run (i.e. loaders), and initial file to run
  # TODO: deal with options containing origin (i.e. parsing a string from externally known location).
  # TODO: should return the model, not a Hostclass
  # 
  # @api private
  #
  def _parse()
      begin
        @yydebug = false
        main = yyparse(@lexer,:scan)
# Commented out now because this hides problems in the racc grammar while developing
# TODO include this when test coverage is good enough.        
#      rescue Puppet::ParseError => except
#        except.line ||= @lexer.line
#        except.file ||= @lexer.file
#        raise except
#      rescue => except
#        raise Puppet::ParseError.new(except.message, @lexer.file, @lexer.line, except)
      end
    return main
  ensure
    @lexer.clear
  end

end
