#!/usr/bin/env ruby

require 'puppet/application'
require 'puppet/rails'
require 'puppet/file_bucket/dipper'
require 'puppet/rails/resource'
require 'puppet/rails/param_value'
require 'puppet/network/client'
require 'puppet/parser/collector'
require 'puppet/provider/naginator'

# Monkey-patch the rails resources so we can
# easily convert them to nagios instances.
class Puppet::Rails::Resource
  def to_param_hash
    values = @params_hash || Puppet::Rails::ParamValue.find_all_params_from_resource(self)
    if values.size == 0
      return {}
    end
    values.inject({}) do |hash, value|
      hash[value['name']] ||= []
      hash[value['name']] << value["value"]
      hash
    end
  end

  def to_nagios
    unless nagios_type = Nagios::Base.type(restype.sub("Nagios_", '').to_sym)
      raise Puppet::DevError, "Could not find nagios type '%s'" % restype
    end

    result = nagios_type.new

    to_param_hash.each do |param, value|
      next unless nagios_type.parameter?(param)
      result[param] = value
    end

    result[:name] = self.title

    result
  end
end

class NagiosWriter
  class FakeScope
    def debug(string)
      Puppet.debug string
    end

    def host
      "this host doesn't exist"
    end
  end

  attr_accessor :nagios_type, :bucket

  def backup(target)
    return unless FileTest.exist?(target) and File.stat(target).size > 0

    Puppet.info "Backing up %s" % target
    bucket.backup(target)
  end

  def collector
    collector = Puppet::Parser::Collector.new(FakeScope.new, "nagios_" + @nagios_type.to_s, nil, nil, :exported)

    # We don't have a scope, so we're stubbing everything out that would interact
    # with the scope.
    class << collector
      def collect_virtual(*args)
        []
      end

      def exported_resource(res)
        res
      end
    end

    collector
  end

  def default_target
    "/etc/nagios/nagios_#{nagios_type.to_s}.cfg"
  end

  def evaluate
    return unless resources = rails_resources()

    resources_by_target = resources.inject({}) do |hash, resource|
      target = resource["target"] || default_target
      hash[target] ||= []
      hash[target] << resource
      hash
    end

    changed = false
    resources_by_target.each do |target, resources|
      begin
        result = write(target, resources)
      rescue => detail
        $stderr.puts detail.backtrace
        Puppet.err "Could not write to %s: %s" % [target, detail]
      end

      changed = true if result
    end

    changed
  end

  def initialize(nagios_type, compare = false)
    @compare = compare
    @nagios_type = nagios_type

    @bucket = Puppet::FileBucket::Dipper.new(:Path => Puppet[:clientbucketdir])
  end

  def rails_resources
    collector.send(:collect_exported)
  end

  def write(target, resources)
    # Skip the nagios type when we have no resources and no existing
    # file.
    return if resources.empty? and ! FileTest.exist?(target)

    dir = File.dirname(target)
    unless FileTest.exist?(dir)
      FileUtils.mkdir_p(dir)
    end

    count = 0

    tempfile = target + ".tmp"
    File.open(tempfile, "w") do |file|
      resources.each do |resource|
        count += 1
        file.puts resource.to_nagios.to_s.gsub("_naginator_name", Puppet::Provider::Naginator::NAME_STRING)
      end
    end

    if @compare
      if FileTest.exist?(target) and File.read(tempfile) == File.read(target)
        return false
      end
    end

    backup(target)

    # Atomic rename
    File.rename(tempfile, target)

    Puppet.notice "Wrote %s resources to %s" % [count, target]

    return true
  ensure
    File.unlink(tempfile) if tempfile and FileTest.exist?(tempfile)
  end
end


class Puppet::Application::Naggen < Puppet::Application

  should_parse_config
  run_mode :naggen

  option("--compare", "-c")
  option("--debug",   "-d")
  option("--verbose", "-v")

  def handle_unknown(opt,arg)
    Puppet.settings.handlearg(opt, arg)
  end

  def main
    if options[:debug]
      Puppet::Util::Log.level = :debug
    elsif options[:verbose]
      Puppet::Util::Log.level = :info
    end

    begin
      require 'nagios'
    rescue LoadError
      require 'puppet/external/nagios'
    end

    changed = false
    Nagios::Base.eachtype do |name, type|
      writer = NagiosWriter.new(name, options[:compare])

      changed = true if writer.evaluate
    end

    if options[:compare] and changed
      exit(1)
    else
      exit(0)
    end

  end

  def help
    <<-HELP
 = Synopsis

 Generate Nagios configurations from Puppet Resources in an ActiveRecord database

 = Usage

   naggen [-h|--help] [-d|--debug] [-v|--verbose] [--compare]

 = Description

 This executable is a means of short-circuiting the process of generating nagios
 configurations on your server using Puppet Exported Resources.  It skips any possible
 naming conflicts resulting from Puppet's resource uniqueness requirements, and it
 also skips the inefficiencies involved in converting and transporting large numbers
 of Puppet resources.

 At the least, the machine that runs this will need ActiveRecord (2.0.2) installed,
 along with any database libraries you use.

 = Options

 Note that any configuration parameter that's valid in the configuration file
 is also a valid long argument.  For example, 'ssldir' is a valid configuration
 parameter, so you can specify '--ssldir <directory>' as an argument.

 You can add naggen-specific settings to your puppet.conf in a '[naggen]' section,
 just like any other executable.

 See the configuration file documentation at
 http://reductivelabs.com/projects/puppet/reference/configref.html for
 the full list of acceptable parameters. A commented list of all
 configuration options can also be generated by running puppet with
 '--genconfig'.

 compare::
   Compare new and old files and only backup and write if the files are different.
   Potentially expensive computationally, but idempotent.  Will exit with 0 if
   no changes were made and 1 if there were.

 debug::
   Enable full debugging.

 detailed-exitcodes::
   Provide transaction information via exit codes.  If this is enabled, an exit
   code of '2' means there were changes, and an exit code of '4' means that there
   were failures during the transaction.

 help::
   Print this help message

 verbose::
   Print extra information.

 = Example

   naggen --storeconfigs --confdir /foo --compare


 = License
   Copyright 2011 Luke Kanies

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
HELP
  end

end

Puppet::Application::Naggen.new.run
